<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>流殃的博客</title>
  
  <subtitle>欢迎来到我的博客</subtitle>
  <link href="https://shyblog.world/atom.xml" rel="self"/>
  
  <link href="https://shyblog.world/"/>
  <updated>2021-07-12T23:24:47.519Z</updated>
  <id>https://shyblog.world/</id>
  
  <author>
    <name>流殃</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>情绪自由</title>
    <link href="https://shyblog.world/posts/3668139362.html"/>
    <id>https://shyblog.world/posts/3668139362.html</id>
    <published>2021-07-10T13:20:24.000Z</published>
    <updated>2021-07-12T23:24:47.519Z</updated>
    
    <content type="html"><![CDATA[<p>主要是来聊一下我对于情绪自由的看法。</p><span id="more"></span><h1 id="今日唠叨"><a href="#今日唠叨" class="headerlink" title="今日唠叨"></a>今日唠叨</h1><p> 今天是周六，无聊的我又在家自己待了一天，三餐外卖，说是要学习spring源码的，但是总是看了一小会，就去看视频了，看看b站，看看LPL比赛，看看向往的生活，看看爱奇艺的自制节目《姐妹俱乐部》。<br> 其实我感觉我和其他的男生有点不太一样，因为他们好像是都不太喜欢综艺节目，我还是比较喜欢综艺节目的，比如我最喜欢的一些语言类节目《脱口秀大会》、《奇葩说》、《吐槽大会》等。<br> 这个《姐妹俱乐部》是我最近追的综艺之一，主要就是来讲述一些关于女性在生活中的困境的。从节目的名字来讲，明显是针对于女性用户来开放的，但是也并没有限制男性观众观看，一开始时出于好奇心，看到这个节目，后来发现，挺有意思的，小小小小情景剧一些场景非常的夸张，最后也可以有一个小小的思考，于是我就开始追这个综艺了，几乎每期都看。</p><h1 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h1><p>这周是第七期，讲的主题是“她的笑，她的哭”，注意了，朋友们，女字旁的她，强调女性，内容主要还是以三位老板为主，讲解了在生活中一些想要自由的哭和笑的时候，却遭到了他人的阻拦，或者说在这个社会 的压力或者这个场景的压力下，而不得不压抑自己的情绪。</p><blockquote><p>如果想要了解这个视频的朋友，可以自己去看下，有些东西可能是需要看视频来自己体会的</p></blockquote><p>下面主要是来谈谈我的理解。</p><p>情绪自由这个主题我认为还是挺有意思的，有句话说的好，既然我们都很难达到财富自由了，难道连情绪自由都要放弃吗？</p><p>其实这个问题恒久存在，一直是在对我们自己的情绪进行限制，尤其是我们中国人，饱受传统思想的熏陶，经常性的压抑自己的情绪，比如说在家庭中，父母看起来总是很坚强，似乎没有见过父母哭的样子，或者说是父母不想把自己脆弱的一面留给孩子。</p><h2 id="母亲的哭泣"><a href="#母亲的哭泣" class="headerlink" title="母亲的哭泣"></a>母亲的哭泣</h2><p>写到这里，突然想起来了，我似乎见过我母亲哭泣的样子，如果我记忆没有错的话，应该还是我把我的母亲弄哭的。</p><blockquote><p>本来想写，我妈的，但是感觉太过口语化，于是改成了母亲</p></blockquote><p>在我记忆不太清晰的样子中，似乎是在我初中回家的一个下午，我当时饥肠辘辘的回到家中，急忙需要食物来填满我的肚子，但是我的母亲，不太记得是因为什么原因了，没有做我想吃的饭，又或者是根本没有做饭，在我请求了我的母亲很长的时间之后，她还是不去为我做饭。</p><p>而我直到现在都还清晰的记得，那时的我，经历了饿的不同阶段，一开始是有点饿，慢慢越来越饿，直到这个饿的感觉达到一个顶峰，那个顶峰是真的难受，确实是有种饿到肚子疼的感觉，而那个时候，我的饭还迟迟没有着落，我也只能硬生生扛过那个时间，过了那个顶峰之后，慢慢的就越来越感觉到，似乎自己没有那么饿了。</p><p>当我终于辛苦的扛过自己的最饿的时候，我的母亲又过了一会才做好饭，端上来给我，而那个时候的我傲娇的很，由于自己比较恨母亲没有早点做好饭，于是就一直在拒绝母亲的喂饭，我已经记不清楚母亲是喂了我自己饭，而当时的我却是一直在拒绝，可能是因为担心我没有吃饭饿着，又或者是因为其他，那是我人生中第一次看到我的母亲在我的面前流泪了，我突然就慌了，不知道该如何自处，只是记得我最后好像流着泪吃完了那个饭，记忆非常的深刻。</p><blockquote><p> 这段母亲的哭泣，是在写文章的时候，临时起意，希望大家不要介意。</p></blockquote><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>情绪自由，我认为对于很多人还是有思考的意义的，比如说我自己吧，由于小的时候，不知道因为一次什么原因，就给自己定了一个小的目标，就是以后不再哭泣。当时可能是觉得哭没有用吧，所以就不想要自己遇到事情再哭了，那并不能解决问题啊。虽然是不知道什么时候制定的目标，但是我自己回想过去的几年中，似乎确实不太有哭泣，不知道是不会了，还是说已经习惯了这种没有哭泣的生活。说起来，还有点小悲伤，一个正常的人竟然不会哭泣了，哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈。我仔细的回想，发现我好像虽然不会因为生活中的事情而哭泣了，但是不知道是因为年龄大了(但是一想，我97年，今天2021年，算一下也就24岁)，变得更加感性了，还是说其他什么原因，我竟然有一次看的一个动作戏哭了，真是发现自己确实比以前感性了，看待事情也确实比以前更加柔和了，不知道这是好是坏。</p><blockquote><p>从那个时候，貌似我给自己的座右铭就定位了，用微笑面对生活</p></blockquote><p>我对于情绪自由的理解其实很简单，就是接纳我们自己，接纳自己的这些正常的情绪，如果你可以允许自己笑，当然也可以允许自己哭泣，这都是我们身为一个正常的人类所拥有的一个正常的反应。</p><p>说起来很简单，接纳我们自己的情绪，但是我们常常因为社会的环境，或者我们的传统思想而不自觉地去限制自己的情绪，这是需要我们意识到的，慢慢的来学会接纳自己，学会释放自己的情绪，而不是过分的压抑。</p><h3 id="朋友"><a href="#朋友" class="headerlink" title="朋友"></a>朋友</h3><p>有一个非常经典的俗语是“爱笑的女孩运气都不会太差”，这个我是听过非常多次了，本来以为就是觉得大家都喜欢爱笑的女孩，但是看了今天的视频才知道，原来这也有另外一层意思啊，就是说爱哭的女孩运气比较差喽，我也是醉了，在如今思想解放的今天，女性的思想也越来越开放，这本应该是一个好的事情，但是什么事情都有一个度，这个度没有把握好，就出现了所谓的女权了。来继续爱笑的女孩这个话题，在朋友的关系中，我们可以喜欢看到女孩的笑容，但是不应该去强迫女孩露出笑容，这其实干涉到了女孩的情绪自由，比较过分，而且当女孩意识过来的时候，可能已经没有做朋友了，因为她不想再压抑自己的情绪了。</p><h3 id="父母"><a href="#父母" class="headerlink" title="父母"></a>父母</h3><p>按照我们中国传统思想来说，作为子女的我们，都是认为父母已经为我们操心的很多了，当我们长大的时候，遇到困难或者说是困难的时候，总是喜欢报喜不报忧。不想要将自己的压力转移到父母的身上，而且他们可能对于这个问题的解决也并不能提供什么帮助。这种情况怎么说那，比较复杂，请听我分析一下。</p><p>这种情况对于我们子女自身而言，一方面不用给父母增加压力，报的都是开心的事儿，但是父母也不是傻子，不会那么容易就相信你生活中不会遇到什么困境，只是觉得你不给他们分享，另一方面，这种压力过大的时候，你自己可能控制不住，无意间泄漏或者父母从你的举止行为间看出来了，但是这种时候，父母通常都会问一下，你要真是不说，父母也没办法，其实我感觉遇到这种情况，讲一下，比较好，有句俗话话说的好，堵不如疏，将事情将讲清楚之后，父母才没有那么担心，虽然他们可能并不能提供一些具体的解决办法。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;主要是来聊一下我对于情绪自由的看法。&lt;/p&gt;</summary>
    
    
    
    
    <category term="闲聊" scheme="https://shyblog.world/tags/%E9%97%B2%E8%81%8A/"/>
    
  </entry>
  
  <entry>
    <title>java的构造函数</title>
    <link href="https://shyblog.world/posts/3513846333.html"/>
    <id>https://shyblog.world/posts/3513846333.html</id>
    <published>2021-06-28T13:22:04.000Z</published>
    <updated>2021-07-12T23:24:47.519Z</updated>
    
    <content type="html"><![CDATA[<p>主要介绍java的构造函数</p><span id="more"></span><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>首先我们肯定要知道什么是构造函数？</p><p>简单来说，就是与类名相同，无返回类型的方法，参数可以为空，一般称之为无参构造，也可以有参数，一般称之为有参构造。</p><h2 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h2><p>比如说有个test类，你想要实例化它，一般都是new test（）；</p><p>这种new 一个类的名称，后面加括号的就是调用的是这个类的无参构造，当然里面如果有参数，调用的就是有参构造了。</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><h3 id="编译报错"><a href="#编译报错" class="headerlink" title="编译报错"></a>编译报错</h3><p>在一个类中，当没有在子类里加super（），也没有在父类里构造无参函数</p><blockquote><p>编译器看到我们在父类里写了有参构造法方法，它就会认为，我们不想让子类在回溯的时候走默认的无参构造方法这条路【super(); 此路不通】，但是我们又没告诉给子类，它应该走哪条路（你给了有参就是告诉我不要走无参，但也没告诉我走有参，那走哪？），所以会报错。 所以，若父类没有提供无参构造方法，但是提供了有参构造方法，就要在子类的无参构造方法里，显示的加上调用父类的有参构造方法语句。 如：super（）；（这里就告诉了去走有参了）</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>无参构造运行是需要往上一级一级找无参，甚至找到object</li><li>如果其中一级只有有参，没有无参，会发生错误。但只有无参，没有有参一定不会出错。</li><li>在以后的Java开发中，若一个类要有带参构造方法，要记得先写无参构造方法。防止类追溯时找不到上级，报错。</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;主要介绍java的构造函数&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>单例模式</title>
    <link href="https://shyblog.world/posts/4049607742.html"/>
    <id>https://shyblog.world/posts/4049607742.html</id>
    <published>2021-06-19T22:40:25.000Z</published>
    <updated>2021-07-12T23:24:47.519Z</updated>
    
    <content type="html"><![CDATA[<p>详细介绍单利模式</p><span id="more"></span><h2 id="核心作用"><a href="#核心作用" class="headerlink" title="核心作用"></a>核心作用</h2><p>保证一个类只有一个实例，并且提供一个访问该实例的全局访问点</p><p>常见的五种单例模式的是实现方式</p><ul><li>饿汉式（线程安全，调用效率高，不能延时加载）</li><li>懒汉式（线程安全，调用效率不高，可以延时加载）</li><li>DCL懒汉式（由于JVM底层内部模型原因，偶尔会出现问题，不推荐使用）</li><li>饿汉式改进（静态内部类，线程安全，调用效率高，可以延时加载）</li><li>枚举单例（线程安全，调用效率高，不能延时加载）</li></ul><h2 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//饿汉式单例模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo1</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1. 私有化构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">demo1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    2. 类初始化的时候，立即加载该对象；由于用了static关键字，在类装载的时候就初始化对象，</span></span><br><span class="line"><span class="comment">//    不存在并发问题，因为一加载就出来了</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> demo1 instance=<span class="keyword">new</span> demo1();</span><br><span class="line">    <span class="comment">//3. 提供获取该对象的方法;由于不存在并发问题，所以没有加synchronized关键字，效率高；如果考虑到并发情况，是要加synchronized关键字的；</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  demo1 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//问题：如果在这个类中，加了一些开辟空间的方法，那么不管我用不用这个类，这个块空间都被占用了，</span></span><br><span class="line"><span class="comment">//浪费了资源，理想情况应该是在调用getInstance方法的时候，再去开辟空间；</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">demo1Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        demo1 instance=demo1.getInstance();</span><br><span class="line">        demo1 instance1=demo1.getInstance();</span><br><span class="line">        System.out.println(instance==instance1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo2</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1. 私有化构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">demo2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2. 类初始化的时候，不立即加载该对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> demo2 instance;</span><br><span class="line">    <span class="comment">//3. 提供获取该对象的方法，由于可能会出现有多个线程来进来的话，需要让他们排队，否则都有问题</span></span><br><span class="line">    <span class="comment">// 所以有synchronized同步这个关键字，效率低！</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> demo2 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            instance=<span class="keyword">new</span> demo2();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">demo2Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        demo2 instance=demo2.getInstance();</span><br><span class="line">        demo2 instance1=demo2.getInstance();</span><br><span class="line">        System.out.println(instance==instance1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DCL懒汉式"><a href="#DCL懒汉式" class="headerlink" title="DCL懒汉式"></a>DCL懒汉式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DCL懒汉式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">demo3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2. 类初始化的时候，不立即加载该对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> demo3 instance;</span><br><span class="line">    <span class="comment">//volatile是后来加的</span></span><br><span class="line">    <span class="comment">//3. 提供获取该对象的方法，由于可能会出现有多个线程来进来的话，需要让他们排队，否则都有问题</span></span><br><span class="line">    <span class="comment">// 所以有synchronized同步这个关键字，效率低！</span></span><br><span class="line">    <span class="comment">//不用synchronized可以用synchronized代码块，锁demo3这个类本身；双重检测</span></span><br><span class="line">    <span class="comment">//分析：现在不需要对整个方法进行同步了，将锁的范围变得更精细了，如果有个进程进来了，发现</span></span><br><span class="line">    <span class="comment">//这个instance对象没有被创建，有一个锁，他首先要和其他进程竞争本类的锁，获得锁之后，再次检查，</span></span><br><span class="line">    <span class="comment">//如果还是null，说明他是第一个竞争到这个锁的，于是他这个线程就负责创建这个对象，其他的线程</span></span><br><span class="line">    <span class="comment">//进来之后，直接调用即可</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  demo3 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (demo3.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance==<span class="keyword">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    instance=<span class="keyword">new</span> demo3();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//由于这个操作不是原子性操作，所以他会经过下面几个步骤</span></span><br><span class="line"><span class="comment">//1.分配内存</span></span><br><span class="line"><span class="comment">//2. 执行构造方法</span></span><br><span class="line"><span class="comment">//3. 执行地址</span></span><br><span class="line"><span class="comment">//可能会出现的问题：极端情况，一个线程进来了，走到instance=new demo3()，还没有出去方法，</span></span><br><span class="line"><span class="comment">//结果另一个线程进来了，就会直接走到 return instance;，这样instance就是一个新的对象，</span></span><br><span class="line"><span class="comment">//破环了单例模式，可能会发生一些意想不到的问题；在这种情况下加volatile关键字；</span></span><br><span class="line"><span class="comment">//volatile可以保证一个线程在对这个变量进行修改的时候，另一个线程，该变量的缓存就失效了，直接读内存中的值</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">demo3Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        demo3 instance=demo3.getInstance();</span><br><span class="line">        demo3 instance1=demo3.getInstance();</span><br><span class="line">        System.out.println(instance==instance1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态内部类实现"><a href="#静态内部类实现" class="headerlink" title="静态内部类实现"></a>静态内部类实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态内部类实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">demo4</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> demo4 instance=<span class="keyword">new</span> demo4();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> demo4 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> InnerClass.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//反射机制可以破坏private</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">demo4Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException </span>&#123;</span><br><span class="line">        demo4 instance=demo4.getInstance();</span><br><span class="line">        <span class="comment">//通过反射拿到instance</span></span><br><span class="line">        Constructor&lt;demo4&gt; demo4Constructor=demo4.class.getDeclaredConstructor(<span class="keyword">null</span>);</span><br><span class="line">        demo4Constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        demo4 instance1=demo4Constructor.newInstance();</span><br><span class="line">        System.out.println(instance==instance1);</span><br><span class="line">        System.out.println(instance.hashCode());</span><br><span class="line">        System.out.println(instance1.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优化静态内部类"><a href="#优化静态内部类" class="headerlink" title="优化静态内部类"></a>优化静态内部类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">demo5</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (demo5.class)&#123;</span><br><span class="line">            <span class="keyword">if</span>(instance!=<span class="keyword">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;不要试图用反射破坏单例模式！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2. 类初始化的时候，不立即加载该对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> demo5 instance;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  demo5 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (demo5.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance==<span class="keyword">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    instance=<span class="keyword">new</span> demo5();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">demo5Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        demo5 instance=demo5.getInstance();</span><br><span class="line">        <span class="comment">//通过反射拿到instance</span></span><br><span class="line">        Constructor&lt;demo5&gt; demo4Constructor=demo5.class.getDeclaredConstructor(<span class="keyword">null</span>);</span><br><span class="line">        demo4Constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        demo5 instance1=demo4Constructor.newInstance();</span><br><span class="line">        System.out.println(instance==instance1);</span><br><span class="line">        System.out.println(instance.hashCode());</span><br><span class="line">        System.out.println(instance1.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//枚举</span></span><br><span class="line"><span class="comment">//反射不能够破坏枚举</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">demo6</span> </span>&#123;</span><br><span class="line">    INTERFACE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> demo6 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INTERFACE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">demo6Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        demo6 anInterface = demo6.INTERFACE;</span><br><span class="line">        demo6 anInterface2 = demo6.INTERFACE;</span><br><span class="line">        System.out.println(anInterface==anInterface2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;详细介绍单利模式&lt;/p&gt;</summary>
    
    
    
    
    <category term="设计模式" scheme="https://shyblog.world/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>开闭原则</title>
    <link href="https://shyblog.world/posts/4110889468.html"/>
    <id>https://shyblog.world/posts/4110889468.html</id>
    <published>2021-06-19T22:32:33.000Z</published>
    <updated>2021-07-12T23:24:47.519Z</updated>
    
    <content type="html"><![CDATA[<p>开闭原则</p><span id="more"></span><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>软件实体应该对扩展开放，对修改关闭，其含义是说一个软件实体应该通过扩展来实现变化，而不是通过修改已有的代码来实现变化</p><h2 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;开闭原则&lt;/p&gt;</summary>
    
    
    
    
    <category term="设计模式" scheme="https://shyblog.world/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>几种通信方式的区别和联系</title>
    <link href="https://shyblog.world/posts/2321636764.html"/>
    <id>https://shyblog.world/posts/2321636764.html</id>
    <published>2021-06-16T23:47:45.000Z</published>
    <updated>2021-07-12T23:24:47.519Z</updated>
    
    <content type="html"><![CDATA[<p>http websocket socket webservice这四种方式的区别和联系</p><span id="more"></span><h2 id="http"><a href="#http" class="headerlink" title="http"></a>http</h2><p>HTTP 是基于请求响应式的，即通信只能由客户端发起，服务端做出响应，无状态，无连接的协议</p><p>http是最初的产生的系统间进行通信的协议</p><p><img src="https://gitee.com/flow_disaster/blog-map-bed/raw/master/img/image-20210617075159770.png" alt="image-20210617075159770"></p><h2 id="websocket"><a href="#websocket" class="headerlink" title="websocket"></a>websocket</h2><h3 id="why"><a href="#why" class="headerlink" title="why"></a>why</h3><p>为什么会出现这个东西？</p><p>是因为在一些特定场景下，需要让服务端主动来发送请求，而不是只能让客户端进行轮询，比如我们想了解今天的天气，只能是客户端向服务器发出请求，服务器返回查询结果。HTTP 协议做不到服务器主动向客户端推送信息。</p><p>这种单向请求的特点，注定了如果服务器有连续的状态变化，客户端要获知就非常麻烦。我们只能使用”轮询”：每隔一段时候，就发出一个询问，了解服务器有没有新的信息。最典型的场景就是聊天室。</p><p><img src="https://gitee.com/flow_disaster/blog-map-bed/raw/master/img/image-20210617075211009.png" alt="image-20210617075211009"></p><h2 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h2><h2 id="service"><a href="#service" class="headerlink" title="service"></a>service</h2><blockquote><p>参考文章：</p><ul><li><a href="https://blog.csdn.net/miao_9/article/details/85286025">https://blog.csdn.net/miao_9/article/details/85286025</a></li></ul></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;http websocket socket webservice这四种方式的区别和联系&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>迪米特法则</title>
    <link href="https://shyblog.world/posts/3956989639.html"/>
    <id>https://shyblog.world/posts/3956989639.html</id>
    <published>2021-06-14T23:54:16.000Z</published>
    <updated>2021-07-12T23:24:47.519Z</updated>
    
    <content type="html"><![CDATA[<p>迪米特法则</p><span id="more"></span><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>迪米特法则（Law of Demeter，LoD）也称为最少知识原则（Least KnowledgePrinciple，LKP），虽然名字不同，但描述的是同一个规则：一个对象应该对其他对象有最少的了解。通俗地讲，一个类应该对自己需要耦合或调用的类知道得最少，你（被耦合或调用的类）的内部是如何复杂都和我没关系，那是你的事情，我就知道你提供的这么多public方法，我就调用这么多，其他的我一概不关心。</p><h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><h3 id="只和朋友类交流"><a href="#只和朋友类交流" class="headerlink" title="只和朋友类交流"></a>只和朋友类交流</h3><p>出现在成员变量、方法的输入输出参数中的类称为成员朋友类</p><h3 id="要和朋友保持距离"><a href="#要和朋友保持距离" class="headerlink" title="要和朋友保持距离"></a>要和朋友保持距离</h3><p>一个类公开的public属性或方法越多，修改时涉及的面也就越大，变更引起的风险扩散也就越大。因此，为了保持朋友类间的距离，在设计时需要反复衡量：是否还可以再减少public方法和属性，是否可以修改为private、package-private（包类型，在类、方法、变量前不加访问权限，则默认为包类型）、protected等访问权限，是否可以加上final关键字等。</p><blockquote><p>注意 迪米特法则要求类“羞涩”一点，尽量不要对外公布太多的public方法和非静态的public变量，尽量内敛，多使用private、package-private、protected等访问权限</p></blockquote><h3 id="是自己的就是自己的"><a href="#是自己的就是自己的" class="headerlink" title="是自己的就是自己的"></a>是自己的就是自己的</h3><p>在实际应用中经常会出现这样一个方法：放在本类中也可以，放在其他类中也没有错，那怎么去衡量呢？你可以坚持这样一个原则：如果一个方法放在本类中，既不增加类间关系，也对本类不产生负面影响，那就放置在本类中。</p><h3 id="谨慎使用Serializable"><a href="#谨慎使用Serializable" class="headerlink" title="谨慎使用Serializable"></a>谨慎使用Serializable</h3><p>因为在使用vo类也就是实体类的时候，经常要序列化才行，如果类中的方法从原来的私有属性，改为了public，就可能会导致接口出现问题，但是这个问题应该是项目管理的问题，不可能服务端修改接口的相应代码，客户端没有接受到通知吧</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>迪米特法则的核心观念就是类间解耦，弱耦合，只有弱耦合了以后，类的复用率才可以提高。其要求的结果就是产生了大量的中转或跳转类，导致系统的复杂性提高，同时也为维护带来了难度。读者在采用迪米特法则时需要反复权衡，既做到让结构清晰，又做到高内聚低耦合。</p><p>一般来说，在实际应用中，如果一个类跳转两次以上才能访问到另一个类，就需要想办法进行重构了，为什么是两次以上呢？因为一个系统的成功不仅仅是一个标准或是原则就能够决定的，有非常多的外在因素决定，跳转次数越多，系统越复杂，维护就越困难，所以只要跳转不超过两次都是可以忍受的，这需要具体问题具体分析。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;迪米特法则&lt;/p&gt;</summary>
    
    
    
    
    <category term="设计模式" scheme="https://shyblog.world/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>接口隔离原则</title>
    <link href="https://shyblog.world/posts/3773597826.html"/>
    <id>https://shyblog.world/posts/3773597826.html</id>
    <published>2021-06-14T02:37:31.000Z</published>
    <updated>2021-07-12T23:24:47.519Z</updated>
    
    <content type="html"><![CDATA[<p>接口隔离原则</p><span id="more"></span><h2 id="接口分类"><a href="#接口分类" class="headerlink" title="接口分类"></a>接口分类</h2><ol><li>java中普通的interface是接口的一种</li><li>new 一个新类的时候，可以将其成为 实例化接口</li></ol><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ol><li>客户端不应该依赖它不需要的接口</li><li>类间的依赖关系应该建立在最小的接口上</li></ol><p>我们可以把这两个定义概括为一句话：建立单一接口，不要建立臃肿庞大的接口。再通俗一点讲：接口尽量细化，同时接口中的方法尽量少</p><h2 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h2><h3 id="接口尽量小"><a href="#接口尽量小" class="headerlink" title="接口尽量小"></a>接口尽量小</h3><p>首先不能违反单一职责原则</p><h3 id="接口要高内聚"><a href="#接口要高内聚" class="headerlink" title="接口要高内聚"></a>接口要高内聚</h3><p>要求在接口中尽量少公布public方法，接口是对外的承诺，承诺越少对系统的开发越有利，变更的风险也就越少，同时也有利于降低成本</p><h3 id="定制服务"><a href="#定制服务" class="headerlink" title="定制服务"></a>定制服务</h3><p>在进行系统设计的时候，要不同的系统间或者系统内不同的模块一定会产生耦合的部分，在这样的情况下，需要为各个访问者提供专用的接口，以确保一个类或者一个接口中提供多个不同访问者的方法的时候，权限没有控制好，导致一个访问者可以查询本来不属于它的方法</p><h3 id="接口设计是有限度的"><a href="#接口设计是有限度的" class="headerlink" title="接口设计是有限度的"></a>接口设计是有限度的</h3><p>接口的设计粒度越小，系统越灵活，这是不争的事实。但是，灵活的同时也带来了结构的复杂化，开发难度增加，可维护性降低，这不是一个项目或产品所期望看到的，所以接口设计一定要注意适度，这个“度”如何来判断呢？根据经验和常识判断，没有一个固化或可测量的标准。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;接口隔离原则&lt;/p&gt;</summary>
    
    
    
    
    <category term="设计模式" scheme="https://shyblog.world/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>动态规划</title>
    <link href="https://shyblog.world/posts/2819424305.html"/>
    <id>https://shyblog.world/posts/2819424305.html</id>
    <published>2021-06-12T13:52:16.000Z</published>
    <updated>2021-07-12T23:24:47.519Z</updated>
    
    <content type="html"><![CDATA[<p>文章摘要</p><span id="more"></span><h2 id="零钱兑换"><a href="#零钱兑换" class="headerlink" title="零钱兑换"></a>零钱兑换</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><img src="https://gitee.com/flow_disaster/blog-map-bed/raw/master/img/image-20210613100037414.png" alt="image-20210613100037414"></p><h3 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> amount, <span class="keyword">int</span>[] coins)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> coin : coins) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = coin; i &lt;= amount; i++) &#123;</span><br><span class="line">            dp[i] += dp[i - coin];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如何列出正确的状态转移方程"><a href="#如何列出正确的状态转移方程" class="headerlink" title="如何列出正确的状态转移方程"></a>如何列出正确的状态转移方程</h2><ol><li> 确定基础的例子</li><li>确定【状态】，也就是原问题和子问题中会变化的变量</li><li>确定【选择】，也就是导致【状态】产生变化的行为</li><li>明确dp函数/数组的定义。自定向下</li></ol><h2 id="备忘录"><a href="#备忘录" class="headerlink" title="备忘录"></a>备忘录</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;文章摘要&lt;/p&gt;</summary>
    
    
    
    
    <category term="算法" scheme="https://shyblog.world/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>oracle表空间</title>
    <link href="https://shyblog.world/posts/3892716853.html"/>
    <id>https://shyblog.world/posts/3892716853.html</id>
    <published>2021-06-12T12:41:21.000Z</published>
    <updated>2021-07-12T23:24:47.519Z</updated>
    
    <content type="html"><![CDATA[<p>详细介绍表空间</p><span id="more"></span><p>在逻辑结构中，Oracle从大到下，分别是如下的结构：<strong>数据库实例 -&gt; 表空间 -&gt; 数据段（表） -&gt; 区 -&gt; 块。</strong></p><p>也就是说当我们要使用Oracle作为项目的数据库时，我们需要先创建数据库实例，之后创建表空间，再创建相对应的表（也就是逻辑结构中的数据段）。</p><p>使用Oracle作为项目的数据库时，我们需要先创建数据库实例，之后创建表空间，再创建相对应的表（也就是逻辑结构中的数据段）。</p><h2 id="常营命令"><a href="#常营命令" class="headerlink" title="常营命令"></a>常营命令</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 给表空间增加大小</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span>space HGCS1031 </span><br><span class="line"><span class="keyword">add</span> datafile <span class="string">&#x27;C:\APP\YSS\PRODUCT\11.2.0\DBHOME_1\DATABASE\HGCS1031_1.DBF&#x27;</span></span><br><span class="line">Size <span class="number">1000</span>M Autoextend <span class="keyword">on</span> maxsize unlimited; </span><br><span class="line">#查看表空间大小</span><br><span class="line"><span class="keyword">select</span> tablespace_name,<span class="built_in">sum</span>(bytes)<span class="operator">/</span><span class="number">1024</span><span class="operator">/</span><span class="number">1024</span> <span class="keyword">from</span> dba_data_files <span class="keyword">group</span> <span class="keyword">by</span> tablespace_name;</span><br><span class="line"># 查看表空间大小已经使用的情况和分配情况</span><br><span class="line"><span class="keyword">select</span> SEGMENT_TYPE,owner,<span class="built_in">sum</span>(bytes)<span class="operator">/</span><span class="number">1024</span><span class="operator">/</span><span class="number">1024</span> <span class="keyword">from</span>  dba_segments  <span class="keyword">where</span> tablespace_name<span class="operator">=</span><span class="string">&#x27;XITONG&#x27;</span> <span class="keyword">group</span> <span class="keyword">by</span> segment_type,owner;</span><br><span class="line"> # 查看block的大小</span><br><span class="line"> <span class="keyword">select</span> <span class="keyword">value</span><span class="operator">/</span><span class="number">1024</span> <span class="keyword">as</span> &quot;kb&quot; <span class="keyword">from</span> v$<span class="keyword">parameter</span> <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;db_block_size&#x27;</span>; </span><br></pre></td></tr></table></figure><p>由于Oracle的Rowid使用22位来代表数据块号，因此Oracle表空间数据文件每个数据文件最多只能包含2^22个数据块。</p><p>也因此数据库表空间的数据文件不是无限增长的，例如：</p><p>在数据块为8k的情况下，单个数据文件的最大容量为8K*2^22 = 32G</p><p>2K = 8G、8K = 32G、16K = 64G、32K = 128G；</p><p>DB_BLOCK_SIZE作为数据库的最小操作单位，是在创建数据库的时候指定的，在创建完数据库之后便不可修改。要修改DB_BLOCK_SIZE，需要重建数据库。一般可以将数据EXP出来，然后重建数据库，指定新的DB_BLOCK_SIZE，然后再将数据IMP进数据库。</p><h2 id="空间不足"><a href="#空间不足" class="headerlink" title="空间不足"></a>空间不足</h2><p>首先选择设置自增长，sql语句：Alter tablespace 表空间名 adddatafile ‘数据文件存放路径‘ autoextend on next 每次增加的大小 maxsize 数据文件大小的最大值</p><h2 id="增加数据文件"><a href="#增加数据文件" class="headerlink" title="增加数据文件"></a>增加数据文件</h2><p>在自增长失灵了之后，需要增加数据文件，sql语句：Alter tablespace 表空间名 adddatafile ‘数据文件存放的路径’ size 数据文件大小M autoextend on next 每次自增长大小M Maxsize UNLIMITED；（后半部分为设置自增长）</p><p>这里放个例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span>space SDE <span class="keyword">add</span> datafile <span class="string">&#x27;E:\app\EmmaXu\product\11.1.0\db_1\database\SDE_1.dbf&#x27;</span> size <span class="number">400</span>Mautoextend off</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;详细介绍表空间&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>零拷贝</title>
    <link href="https://shyblog.world/posts/1857813313.html"/>
    <id>https://shyblog.world/posts/1857813313.html</id>
    <published>2021-05-26T11:01:34.000Z</published>
    <updated>2021-07-12T23:24:47.519Z</updated>
    
    <content type="html"><![CDATA[<p>主要是介绍零拷贝的两种技术原理</p><span id="more"></span><h2 id="what"><a href="#what" class="headerlink" title="what"></a>what</h2><p>零拷贝并不是不需要拷贝，而是减少不必要的拷贝次数。通常是说在IO读写过程中。</p><p>实际上，零拷贝是有广义和狭义之分，目前我们通常听到的零拷贝，包括上面这个定义<code>减少不必要的拷贝次数</code>都是广义上的零拷贝。其实了解到这点就足够了。</p><p>我们知道，减少不必要的拷贝次数，就是为了提高效率。那零拷贝之前，是怎样的呢？</p><h2 id="传统IO"><a href="#传统IO" class="headerlink" title="传统IO"></a>传统IO</h2><p><img src="https://gitee.com/flow_disaster/blog-map-bed/raw/master/img/image-20210526193401096.png" alt="image-20210526193401096"></p><p>传统IO</p><ol><li>将磁盘文件，拷贝到操作系统内核缓冲区</li><li>将内核缓冲区的数据，拷贝到应用程序的buffer</li><li>将应用程序buffer中的数据，再拷贝到socket网络发送缓冲区（属于内核缓冲区）</li><li>将socket buffer数据，拷贝到网卡，由网卡进行网络传输</li></ol><p>传统IO方式，读取磁盘文件进行网络发送，经过4次数据拷贝。但是第2、3次的拷贝明显没有什么帮助。</p><p>传统IO存在多次无效拷贝，还伴随着大量的上下文切换。</p><h2 id="MMAP"><a href="#MMAP" class="headerlink" title="MMAP"></a>MMAP</h2><p><img src="https://gitee.com/flow_disaster/blog-map-bed/raw/master/img/image-20210526193525042.png" alt="image-20210526193525042"></p><p><strong>这种方式使用mmap()代替了read()</strong></p><ol><li>磁盘的数据通过DMA拷贝到内核缓冲区</li><li>操作系统把这块内核缓冲区与应用程序共享，避免了用户缓冲区和内核缓冲区的跨界复制</li><li>应用程序调用write()直接从内核缓冲区的内容拷贝到socket缓冲区</li><li>最后系统将socket的数据传输到网卡，由网卡进行传输</li></ol><p><strong>MMAP减少了一次拷贝，提升了效率，但是并不减少上下文切换的次数。</strong></p><h2 id="SendFile"><a href="#SendFile" class="headerlink" title="SendFile"></a>SendFile</h2><p><img src="https://gitee.com/flow_disaster/blog-map-bed/raw/master/img/image-20210526194611101.png" alt="image-20210526194611101"></p><p><strong>这种方式是使用sendfile代替了read+write操作</strong></p><ol><li>首先sendfile系统调用，通过DMA引擎将磁盘文件拷贝到内存缓冲区</li><li>在内核缓冲区，内核将数据拷贝到socket缓冲区</li><li>最后，DMA将数据从内核拷贝到网卡，由网卡传输</li></ol><p>数据总共发生3次拷贝</p><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><ol><li>都是Linux内核提供，实现<a href="https://www.20zyn.cn/tag/%E9%9B%B6%E6%8B%B7%E8%B4%9D/">零拷贝</a>的API</li><li>sendfile是将读到内核缓冲区的数据，直接转到socket buffer，进行网络发送</li><li>mmap是将磁盘文件读取到内核缓冲区后进行映射，和用户缓冲区共享数据，然后CPU在拷贝数据到socket buffer，进行网络发送</li></ol><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.20zyn.cn/kafka%E7%9A%84%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%8A%80%E6%9C%AF/">kafka的零拷贝技术</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;主要是介绍零拷贝的两种技术原理&lt;/p&gt;</summary>
    
    
    
    
    <category term="操作系统" scheme="https://shyblog.world/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Spring循环依赖</title>
    <link href="https://shyblog.world/posts/2782423641.html"/>
    <id>https://shyblog.world/posts/2782423641.html</id>
    <published>2021-05-25T01:21:04.000Z</published>
    <updated>2021-07-12T23:24:47.519Z</updated>
    
    <content type="html"><![CDATA[<p>文章摘要</p><span id="more"></span><blockquote><p>参考链接：</p><ul><li><a href="https://www.bilibili.com/video/BV155411c7gg">B站视频讲解</a></li></ul></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;文章摘要&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>实现一个简单的计算器</title>
    <link href="https://shyblog.world/posts/4113357341.html"/>
    <id>https://shyblog.world/posts/4113357341.html</id>
    <published>2021-05-23T05:32:04.000Z</published>
    <updated>2021-07-12T23:24:47.519Z</updated>
    
    <content type="html"><![CDATA[<p>文章摘要</p><span id="more"></span><h2 id="两个栈"><a href="#两个栈" class="headerlink" title="两个栈"></a>两个栈</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    Deque&lt;Integer&gt; stack = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">char</span> preSign = <span class="string">&#x27;+&#x27;</span>;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = s.length();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="comment">//判断这个字符是否是数字</span></span><br><span class="line">        <span class="keyword">if</span> (Character.isDigit(s.charAt(i))) &#123;</span><br><span class="line">            <span class="comment">//字符和字符的加减法都是用的对应的ASCII来进行的，由于字符对应的ASCII码也是按照数字的大小来的，所以直接就相当于字符直接相加减</span></span><br><span class="line">            num = num * <span class="number">10</span> + s.charAt(i) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!Character.isDigit(s.charAt(i)) &amp;&amp; s.charAt(i) != <span class="string">&#x27; &#x27;</span> || i == n - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (preSign) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                    stack.push(num);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                    stack.push(-num);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                    stack.push(stack.pop() * num);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    stack.push(stack.pop() / num);</span><br><span class="line">            &#125;</span><br><span class="line">            preSign = s.charAt(i);</span><br><span class="line">            num = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        ans += stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一个栈"><a href="#一个栈" class="headerlink" title="一个栈"></a>一个栈</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">double</span> <span class="title">calculate</span><span class="params">(String s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len=s.length();</span><br><span class="line">    <span class="keyword">char</span>[] str=s.toCharArray();</span><br><span class="line">    Stack&lt;Integer&gt; st_num=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">char</span> op=<span class="string">&#x27;#&#x27;</span>;         <span class="comment">//记录乘除符号</span></span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>,sign=<span class="number">1</span>;    <span class="comment">//记录加减符号</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(str[i]==<span class="string">&#x27; &#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(str[i]&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;str[i]&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> num=str[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;len-<span class="number">1</span>&amp;&amp;str[i+<span class="number">1</span>]&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;str[i+<span class="number">1</span>]&lt;=<span class="string">&#x27;9&#x27;</span>)  <span class="comment">//找完这个数</span></span><br><span class="line">                num=num*<span class="number">10</span>+(str[++i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span>(op!=<span class="string">&#x27;#&#x27;</span>)&#123;                                <span class="comment">//如果之前有乘除符号</span></span><br><span class="line">                <span class="keyword">if</span>(op==<span class="string">&#x27;*&#x27;</span>)num*=st_num.pop();           <span class="comment">//则将这个数运算之后，再重新进栈</span></span><br><span class="line">                <span class="keyword">else</span> num=st_num.pop()/num;</span><br><span class="line">                op=<span class="string">&#x27;#&#x27;</span>;                                <span class="comment">//重置乘除符号</span></span><br><span class="line">            &#125;</span><br><span class="line">            st_num.push(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(str[i]==<span class="string">&#x27;*&#x27;</span>||str[i]==<span class="string">&#x27;/&#x27;</span>) op=str[i];  <span class="comment">//更新乘除符号</span></span><br><span class="line">        <span class="keyword">else</span>&#123;                                         <span class="comment">//遇到加减符号则可以直接更新ans了</span></span><br><span class="line">            ans+=st_num.pop()*sign;</span><br><span class="line">            sign=str[i]==<span class="string">&#x27;+&#x27;</span>?<span class="number">1</span>:-<span class="number">1</span>;   <span class="comment">//更新加减符号</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans+st_num.pop()*sign;   <span class="comment">//sign更新后，还有一次未计算</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;文章摘要&lt;/p&gt;</summary>
    
    
    
    
    <category term="栈" scheme="https://shyblog.world/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>ThreadPoolExecutor</title>
    <link href="https://shyblog.world/posts/2504375410.html"/>
    <id>https://shyblog.world/posts/2504375410.html</id>
    <published>2021-05-22T01:36:33.000Z</published>
    <updated>2021-07-12T23:24:47.519Z</updated>
    
    <content type="html"><![CDATA[<p>从源码层面来详细了解</p><span id="more"></span><h2 id="why"><a href="#why" class="headerlink" title="why"></a>why</h2><p>为什么要使用线程池？</p><p>线程过多会带来额外的开销，其中包括创建销毁线程的开销、调度线程的开销等等，同时也降低了计算机的整体性能。线程池维护多个线程，等待监督管理者分配可并发执行的任务。这种做法，一方面避免了处理任务时创建销毁线程开销的代价，另一方面避免了线程数量膨胀导致的过分调度问题，保证了对内核的充分利用。</p><h2 id="what"><a href="#what" class="headerlink" title="what"></a>what</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ctl就是把线程的运行状态和工作线程数进行统一管理的</span></span><br><span class="line"><span class="comment">//AtomicInteger这个类可以通过CAS达到无锁并发，效率比较高,这个变量有双重身份，它的高三位表示线程池的状态，低29位表示线程池中现有的线程数，这也是Doug Lea一个天才的设计，用最少的变量来减少锁竞争，提高并发效率。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"><span class="comment">///表示线程池线程数的bit数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"><span class="comment">//最大的线程数量，数量是完全够用了</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// runState is stored in the high-order bits</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Packing and unpacking ctl</span></span><br><span class="line"><span class="comment">//获取线程池的状态</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span>     </span>&#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class="line"><span class="comment">//获取线程的数量</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span>  </span>&#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123; <span class="keyword">return</span> rs | wc; &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Bit field accessors that don&#x27;t require unpacking ctl.</span></span><br><span class="line"><span class="comment">     * These depend on the bit layout and on workerCount being never negative.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">runStateLessThan</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c &lt; s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">runStateAtLeast</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c &gt;= s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isRunning</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c &lt; SHUTDOWN;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><ul><li>RUNNING, 运行状态，值也是最小的，刚创建的线程池就是此状态，能接受新提交的任务，并且也能处理阻塞队列中的任务</li><li>SHUTDOWN，关闭状态，不再接受新提交的任务，但却可以继续处理阻塞队列中已保存的任务。在线程池处于 RUNNING 状态时，调用 shutdown()方法会使线程池进入到该状态。（finalize() 方法在执行过程中也会调用shutdown()方法进入该状态）</li><li>STOP，不能接受新任务，也不处理队列中的任务，会中断正在处理任务的线程。在线程池处于 RUNNING 或 SHUTDOWN 状态时，调用 shutdownNow() 方法会使线程池进入到该状态；</li><li>TIDYING，如果所有的任务都已终止了，workerCount (有效线程数) 为0，线程池进入该状态后会调用 terminated() 方法进入TERMINATED 状态。</li><li>TERMINATED，在terminated() 方法执行完后进入该状态，默认terminated()方法中什么也没有做。</li></ul><p><img src="https://gitee.com/flow_disaster/blog-map-bed/raw/master/img/image-20210523080302512.png" alt="image-20210523080302512"></p><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">         Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>corePoolSize</strong>：核心线程数量，当有新任务在execute()方法提交时，会执行以下判断：</p><ol><li>如果运行的线程少于 corePoolSize，则创建新线程来处理任务，即使线程池中的其他线程是空闲的；</li><li>如果线程池中的线程数量大于等于 corePoolSize 且小于 maximumPoolSize，则只有当workQueue满时才创建新的线程去处理任务；</li><li>如果设置的corePoolSize 和 maximumPoolSize相同，则创建的线程池的大小是固定的，这时如果有新任务提交，若workQueue未满，则将请求放入workQueue中，等待有空闲的线程去从workQueue中取任务并处理；</li><li>如果运行的线程数量大于等于maximumPoolSize，这时如果workQueue已经满了，则通过handler所指定的策略来处理任务；</li></ol><p>所以，任务提交时，判断的顺序为 corePoolSize –&gt; workQueue –&gt; maximumPoolSize。</p></li><li><p><strong>maximumPoolSize</strong>：最大线程数量；</p></li><li><p><strong>workQueue</strong>：等待队列，当任务提交时，如果线程池中的线程数量大于等于corePoolSize的时候，把该任务封装成一个Worker对象放入等待队列；</p></li><li><p>workQueue</p><p>：保存等待执行的任务的阻塞队列，当提交一个新的任务到线程池以后, 线程池会根据当前线程池中正在运行着的线程的数量来决定对该任务的处理方式，主要有以下几种处理方式:</p><ol><li><p><strong>直接切换</strong>：这种方式常用的队列是SynchronousQueue，但现在还没有研究过该队列，这里暂时还没法介绍；</p></li><li><p><strong>使用无界队列</strong>：一般使用基于链表的阻塞队列LinkedBlockingQueue。如果使用这种方式，那么线程池中能够创建的最大线程数就是corePoolSize，而maximumPoolSize就不会起作用了（后面也会说到）。当线程池中所有的核心线程都是RUNNING状态时，这时一个新的任务提交就会放入等待队列中。</p></li><li><p>使用有界队列</p><p>：一般使用ArrayBlockingQueue。使用该方式可以将线程池的最大线程数量限制为maximumPoolSize，这样能够降低资源的消耗，但同时这种方式也使得线程池对线程的调度变得更困难，因为线程池和队列的容量都是有限的值，所以要想使线程池处理任务的吞吐率达到一个相对合理的范围，又想使线程调度相对简单，并且还要尽可能的降低线程池对资源的消耗，就需要合理的设置这两个数量。</p><ul><li>如果要想降低系统资源的消耗（包括CPU的使用率，操作系统资源的消耗，上下文环境切换的开销等）, 可以设置较大的队列容量和较小的线程池容量, 但这样也会降低线程处理任务的吞吐量。</li><li>如果提交的任务经常发生阻塞，那么可以考虑通过调用 setMaximumPoolSize() 方法来重新设定线程池的容量。</li><li>如果队列的容量设置的较小，通常需要将线程池的容量设置大一点，这样CPU的使用率会相对的高一些。但如果线程池的容量设置的过大，则在提交的任务数量太多的情况下，并发量会增加，那么线程之间的调度就是一个要考虑的问题，因为这样反而有可能降低处理任务的吞吐量。</li></ul></li></ol></li><li><p><strong>keepAliveTime</strong>：线程池维护线程所允许的空闲时间。当线程池中的线程数量大于corePoolSize的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了keepAliveTime；</p></li><li><p><strong>threadFactory</strong>：它是ThreadFactory类型的变量，用来创建新线程。默认使用Executors.defaultThreadFactory() 来创建线程。使用默认的ThreadFactory来创建线程时，会使新创建的线程具有相同的NORM_PRIORITY优先级并且是非守护线程，同时也设置了线程的名称。</p></li><li><p>handler</p><p>：它是RejectedExecutionHandler类型的变量，表示线程池的饱和策略。如果阻塞队列满了并且没有空闲的线程，这时如果继续提交任务，就需要采取一种策略处理该任务。线程池提供了4种策略：</p><ol><li>AbortPolicy：直接抛出异常，这是默认策略；</li><li>CallerRunsPolicy：用调用者所在的线程来执行任务；</li><li>DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务；</li><li>DiscardPolicy：直接丢弃任务；</li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//上面的this调用的就是这个方法，这个方法中会进行一些异常情况的判断</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.acc = System.getSecurityManager() == <span class="keyword">null</span> ?</span><br><span class="line">            <span class="keyword">null</span> :</span><br><span class="line">            AccessController.getContext();</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="execute方法"><a href="#execute方法" class="headerlink" title="execute方法"></a>execute方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">//ctl的低29位表示线程数，高三位表示线程的状态</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="comment">//如果正在工作的线程数小于核心线程数，就需要增加一个线程</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//如果增加线程失败，就会重新获取ctl</span></span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html">https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html</a></li><li><a href="http://www.ideabuffer.cn/2017/04/04/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9AThreadPoolExecutor/">http://www.ideabuffer.cn/2017/04/04/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9AThreadPoolExecutor/</a>****</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;从源码层面来详细了解&lt;/p&gt;</summary>
    
    
    
    
    <category term="java" scheme="https://shyblog.world/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud1</title>
    <link href="https://shyblog.world/posts/4079009569.html"/>
    <id>https://shyblog.world/posts/4079009569.html</id>
    <published>2021-05-20T02:28:11.000Z</published>
    <updated>2021-07-12T23:24:47.515Z</updated>
    
    <content type="html"><![CDATA[<p>文章摘要</p><span id="more"></span><p>SpringCloudNetFlix</p><h1 id="核心问题"><a href="#核心问题" class="headerlink" title="核心问题"></a>核心问题</h1><p>微服务架构核心问题</p><ol><li>服务很多，客户端如何访问</li><li>这么多服务，服务之间如何通信</li><li>如何治理服务</li><li>服务挂了怎么办</li></ol><p>解决方案</p><p>Spring Cloud 生态</p><ol><li>Spring Cloud  NetFlix   一站式解决方案！</li></ol><ul><li>api网关：zuul组件</li><li>服务调用 Feign–HttpClinet   http通信方式。同步 阻塞</li><li>服务注册发现 Eureka</li><li>熔断机制 Hystrix</li><li>负载均衡 ribbon</li></ul><ol><li>Apache Dubbo Zookeeper  半自动，需要整合别人的</li></ol><ul><li>api：没有，用第三方插件，或者自己实现</li><li>Dubbo</li><li>Zookeeper</li><li>没有，借助 Hystrix</li></ul><ol><li>Spring Cloud Alibaba   最新的 一站式解决方案  更简单</li></ol><h1 id="认识Spring-Cloud"><a href="#认识Spring-Cloud" class="headerlink" title="认识Spring Cloud"></a>认识Spring Cloud</h1><p>springboot专注于快速、方便的开发单个个体微服务，springCloud关注全局协调的微服务框架</p><p>现在大型网站的架构图</p><p><img src="https://gitee.com/flow_disaster/blog-map-bed/raw/master/img/image-20210520103022522.png" alt="image-20210520103022522"></p><h1 id="Spring-Cloud-NetFlix"><a href="#Spring-Cloud-NetFlix" class="headerlink" title="Spring Cloud  NetFlix"></a>Spring Cloud  NetFlix</h1><h2 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h2><p>服务注册和服务发现</p><p>必须要进行参数优化，否则速度太慢</p><p>nacos zookeeper rockemq中的nameserver也是这个作用</p><p>consul</p><p><img src="https://gitee.com/flow_disaster/blog-map-bed/raw/master/img/image-20210520103056022.png" alt="image-20210520103056022"></p><p>为什么要搞两级缓存</p><p>目的就是为了避免并发冲突</p><h3 id="集群模式"><a href="#集群模式" class="headerlink" title="集群模式"></a>集群模式</h3><p><img src="https://gitee.com/flow_disaster/blog-map-bed/raw/master/img/image-20210520103108643.png" alt="image-20210520103108643"></p><h2 id="Eureka优化"><a href="#Eureka优化" class="headerlink" title="Eureka优化"></a>Eureka优化</h2><p><img src="https://gitee.com/flow_disaster/blog-map-bed/raw/master/img/image-20210520103206520.png" alt="image-20210520103206520"></p><h2 id="Eureka和Zookeeper区别"><a href="#Eureka和Zookeeper区别" class="headerlink" title="Eureka和Zookeeper区别"></a>Eureka和Zookeeper区别</h2><p>CAP理论：</p><ul><li>C 一致性</li><li>A 可用性</li><li>P 容错性</li></ul><p>由于分区容错P在分布式系统中是必须要保证的，因此，偶问你只能在A和P之间进行权衡</p><ul><li>Zookeeper保证的是CP</li><li>Eureka保证的是AP</li></ul><h2 id="Feign"><a href="#Feign" class="headerlink" title="Feign"></a>Feign</h2><p>服务调用</p><p>整合eureka和ribbon</p><p>Feign是面向接口的</p><h2 id="Ribbon"><a href="#Ribbon" class="headerlink" title="Ribbon"></a>Ribbon</h2><p>负载均衡</p><p>服务第一次被调用的时候，他会初始话一个ribbon组件，初始化这些组件可能会耗费一定时间，所以很容易导致服务超时。开启下面参数，让每个服务启动的时候就直接初始化ribbon相关的组件，避免第一次请求的时候初始化</p><p><img src="https://gitee.com/flow_disaster/blog-map-bed/raw/master/img/image-20210520103340803.png" alt="image-20210520103340803"></p><h2 id="Hystrix"><a href="#Hystrix" class="headerlink" title="Hystrix"></a>Hystrix</h2><p>服务熔断在服务端</p><p>服务降级在客户端</p><blockquote><p>服务熔断</p></blockquote><ol><li>定义：某个服务超时或者异常，引起熔断   类似于保险丝的作用</li><li>一般发生在服务端</li></ol><blockquote><p>服务降级</p></blockquote><ol><li>定义：从整体网站请求负载考虑，当前某些服务访问量比较大，会暂时关闭一些访问量比较小的服务，将整个网站的资源倾斜在访问量比较大的服务上，等到访问量下来，就重新开启那些服务；此时在客户端上，我们可以准备一个FallbackFactory，返回默认的值，提示用户当前的服务不可用</li><li>一般发生在客户端</li></ol><h2 id="Zuul"><a href="#Zuul" class="headerlink" title="Zuul"></a>Zuul</h2><p>路由网关，用户一进来接触的组件就是路由网关</p><p><img src="https://gitee.com/flow_disaster/blog-map-bed/raw/master/img/image-20210520103304727.png" alt="image-20210520103304727"></p><p>主要功能：</p><ul><li>路由</li><li>过滤</li></ul><p>zuul服务最终还是会注册到Eureka中</p><h1 id="zookeeper"><a href="#zookeeper" class="headerlink" title="zookeeper"></a>zookeeper</h1><p><img src="https://gitee.com/flow_disaster/blog-map-bed/raw/master/img/image-20210520103250856.png" alt="image-20210520103250856"></p><h1 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h1><h2 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h2><ol><li>动态路由</li><li>灰度发布</li><li>授权认证</li><li>性能监控</li><li>系统日志</li><li>数据缓存</li><li>限流熔断</li></ol><p>kong zuul ngnix+lua（openresty） 自研网关</p><p>大厂基本上都是基于netty做的自有网关</p><p>zuul：基于java开发，功能比较简单，但是比如灰度发布，限流，动态路由等没有这些功能</p><p>kong：依托于ngnix实现，openresty，lua实现的模块，现成的一些插件，可以直接使用</p><h2 id="zuul"><a href="#zuul" class="headerlink" title="zuul"></a>zuul</h2><p>一般来讲一台8核16g的zuul每秒抗1000+不成问题</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;文章摘要&lt;/p&gt;</summary>
    
    
    
    
    <category term="SpringCloud" scheme="https://shyblog.world/tags/SpringCloud/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ</title>
    <link href="https://shyblog.world/posts/3041119952.html"/>
    <id>https://shyblog.world/posts/3041119952.html</id>
    <published>2021-05-19T23:16:18.000Z</published>
    <updated>2021-07-12T23:24:47.515Z</updated>
    
    <content type="html"><![CDATA[<p>文章摘要</p><span id="more"></span><h3 id="保证消息不丢失"><a href="#保证消息不丢失" class="headerlink" title="保证消息不丢失"></a>保证消息不丢失</h3><h4 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h4><p>通过rabbitmq的一个confirm机制，消息发送到mq之后，将消息持久化到磁盘之后，才会返回confirm给生产者</p><h4 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h4><p>rabbitmq默认的是自动ack的机制，但是可能会发生消费者已经收到消息，但是还没有来得及处理消息就宕机的情况，这中情况下，会出现消息丢失的情况</p><blockquote><p>自动ack的机制：</p><p>就是消费者只要接收到mq的消息，就会立即返回ack，不管消息是否已经处理完毕</p></blockquote><p>所以采用手动ack机制来确保，消息处理完毕之后，才将ack发送给mq集群</p><h4 id="高并发"><a href="#高并发" class="headerlink" title="高并发"></a>高并发</h4><p>⾸先，⽤来临时存放未 ack 消息的存储需要承载⾼并发写⼊，⽽且我们不需要什么复杂的运算 操作，这种存储⾸选绝对不是 MySQL 之类的数据库，⽽建议采⽤ kv 存储。kv 存储承载⾼并发 能⼒极强，⽽且 kv 操作性能很⾼。 其次，投递消息之后等待 ack 的过程必须是异步的，也就是类似上⾯那样的代码，已经给出了 ⼀个初步的异步回调的⽅式。 消息投递出去之后，这个投递的线程其实就可以返回了，⾄于每个消息的异步回调，是通过在 channel 注册⼀个 confirm 监听器实现的。 收到⼀个消息 ack 之后，就从 kv 存储中删除这条临时消息；收到⼀个消息 nack 之后，就从 kv 存储提取这条消息然后重新投递⼀次即可；也可以⾃⼰对 kv 存储⾥的消息做监控，如果超过⼀ 定时⻓没收到 ack，就主动重发消息。</p><h3 id="ack机制原理"><a href="#ack机制原理" class="headerlink" title="ack机制原理"></a>ack机制原理</h3><p>主要是通过delivery tag</p><p>delivery tag是一次消息的唯一标识，delivery tag是在一次channle中传递的</p><h3 id="消息积压"><a href="#消息积压" class="headerlink" title="消息积压"></a>消息积压</h3><p>这个消息积压，主要是当你开启批量处理ack消息的时候，很多消息目前处于unack的情况</p><p>RabbitMQ基于一个prefetch count来控制这个unack message的数量。</p><p>如果消息的数量小于这个prefetch count，会继续将消息放入这个channel中，如果大于，必须要等待已经投递过去的消息被ack了，此时才能继续投递下一个消息。</p><p>prefetch count的这个数量非常重要</p><ul><li>如果设置过大，会导致mq中存储了海量的数据，会导致消费者服务直接被击垮了，内存溢出，OOM，服务宕机，然后大量unack的消息会被重新投递给其他的消费者服务，此时其他消费者服务一样的情况，直接宕机，最后造成<strong>雪崩效应</strong>。</li><li>如果设置过小，此时就必然会导致消费者服务的吞吐量极低。因为你即使处理完一条消息，执行ack了也是异步的。</li></ul><p>所以鉴于上面两种极端情况，RabbitMQ官方给出的建议是<strong>prefetch count一般设置在100~300之间。</strong></p><h3 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h3><h4 id="普通集群模式"><a href="#普通集群模式" class="headerlink" title="普通集群模式"></a>普通集群模式</h4><p><img src="https://gitee.com/flow_disaster/blog-map-bed/raw/master/img/image-20210521080303083.png" alt="image-20210521080303083"></p><p>这种模式严格来说不算是分布式的结构，因为它所有的数据都是在一台机器上的，消费者消费的时候可以在任意一个rabbitmq中进行消费，如果没有实际数据，就从有实际数据上的mq上进行拉取元数据、真实数据的描述如具体位置等</p><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ol><li>提高吞吐量，可以从多个节点来消费信息</li></ol><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ol><li>如果放实际数据的mq宕机了，基本上这个架构就失效了</li><li>集群内部有大量数据传输</li><li>可用性几乎没有保障</li></ol><h4 id="镜像集群模式"><a href="#镜像集群模式" class="headerlink" title="镜像集群模式"></a>镜像集群模式</h4><p><img src="https://gitee.com/flow_disaster/blog-map-bed/raw/master/img/image-20210521080335361.png" alt="image-20210521080335361"></p><p>生产者生产一条消息，将消息发送到一个mq中，mq会自动将信息同步到其他的mq上，每个mq上的数</p><p>据都是一样的，所以称之为镜像集群模式</p><h5 id="开启方式"><a href="#开启方式" class="headerlink" title="开启方式"></a>开启方式</h5><p>rabbitmq有个很好的控制台，新增一条策略、这个策略就是开启开启镜像集群模式策略、指定的时候可以指定数据同步到所有的节点，也可以要求同步到指定的节点数量，之后你在创建queue时使用这个策略、就会在动降数据同步到其它节点上去了。</p><h5 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h5><ol><li>性能开销太大，消息同步到所有的节点服务器会导致网络带宽压力和消耗很严重。</li><li>这种模式没有扩展性可言，如果你某个queue的负载很高，你加机器，新增的机器也包含了这个queue的所有数据，并没有办法线性扩展你的queue</li><li>不是分布式的</li></ol><blockquote><p>为什么不是分布式的那？ 因为所有的数据还是单独存在在每一个机器上，而分布式应该是将数据存储在不同的的机器上，几个机器上合起来的数据才是一个完整的数据</p></blockquote><h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><h4 id="批量发送ack消息"><a href="#批量发送ack消息" class="headerlink" title="批量发送ack消息"></a>批量发送ack消息</h4>]]></content>
    
    
    <summary type="html">&lt;p&gt;文章摘要&lt;/p&gt;</summary>
    
    
    
    
    <category term="RabbitMQ" scheme="https://shyblog.world/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>session，cookie和token</title>
    <link href="https://shyblog.world/posts/3324693535.html"/>
    <id>https://shyblog.world/posts/3324693535.html</id>
    <published>2021-05-15T00:38:55.000Z</published>
    <updated>2021-07-12T23:24:47.519Z</updated>
    
    <content type="html"><![CDATA[<p>三种的区别</p><span id="more"></span><h2 id="http"><a href="#http" class="headerlink" title="http"></a>http</h2><p>什么是无状态呢？就是说这一次请求和上一次请求是没有任何关系的，互不认识的，没有关联的。这种无状态的的好处是快速。坏处是假如我们想要把<code>www.zhihu.com/login.html</code>和<code>www.zhihu.com/index.html</code>关联起来，必须使用某些手段和工具</p><h2 id="cookie和session"><a href="#cookie和session" class="headerlink" title="cookie和session"></a>cookie和session</h2><p>cookie是session的一种实现方案</p><p>客户端访问服务器的流程如下：</p><ul><li>首先，客户端会发送一个http请求到服务器端。</li><li>服务器端接受客户端请求后，建立一个session，并发送一个http响应到客户端，这个响应头，其中就包含Set-Cookie头部。该头部包含了sessionId。Set-Cookie格式如下，具体请看<a href="http://bubkoo.com/2014/04/21/http-cookies-explained/">Cookie详解</a><br><code>Set-Cookie: value[; expires=date][; domain=domain][; path=path][; secure]</code></li><li>在客户端发起的第二次请求，假如服务器给了set-Cookie，浏览器会自动在请求头中添加cookie</li><li>服务器接收请求，分解cookie，验证信息，核对成功后返回response给客户端</li></ul><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul><li>cookie只是实现session的其中一种方案。虽然是最常用的，但并不是唯一的方法。禁用cookie后还有其他方法存储，比如放在url中</li><li>现在大多都是Session + Cookie，但是只用session不用cookie，或是只用cookie，不用session在理论上都可以保持会话状态。可是实际中因为多种原因，一般不会单独使用</li><li>用session只需要在客户端保存一个id，实际上大量数据都是保存在服务端。如果全部用cookie，数据量大的时候客户端是没有那么多空间的。</li><li>如果只用cookie不用session，那么账户信息全部保存在客户端，一旦被劫持，全部信息都会泄露。并且客户端数据量变大，网络传输的数据量也会变大</li></ul><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul><li>session是保存在服务端的，cookie是保存在客户端的</li></ul><h2 id="token"><a href="#token" class="headerlink" title="token"></a>token</h2><p>token 也称作令牌，由uid+time+sign[+固定参数]<br>token 的认证方式类似于<strong>临时的证书签名</strong>, 并且是一种服务端无状态的认证方式, 非常适合于 REST API 的场景. 所谓无状态就是服务端并不会保存身份认证相关的数据。</p><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><ul><li>uid: 用户唯一身份标识</li><li>time: 当前时间的时间戳</li><li>sign: 签名, 使用 hash/encrypt 压缩成定长的十六进制字符串，以防止第三方恶意拼接</li><li>固定参数(可选): 将一些常用的固定参数加入到 token 中是为了避免重复查库</li></ul><h3 id="存放"><a href="#存放" class="headerlink" title="存放"></a>存放</h3><p>token在客户端一般存放于localStorage，cookie，或sessionStorage中。在服务器一般存于数据库中</p><blockquote><p>参考链接：</p><ul><li><a href="https://segmentfault.com/a/1190000017831088">https://segmentfault.com/a/1190000017831088</a></li></ul></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;三种的区别&lt;/p&gt;</summary>
    
    
    
    
    <category term="网络" scheme="https://shyblog.world/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot自动装配</title>
    <link href="https://shyblog.world/posts/3571835313.html"/>
    <id>https://shyblog.world/posts/3571835313.html</id>
    <published>2021-05-13T14:01:13.000Z</published>
    <updated>2021-07-12T23:24:47.515Z</updated>
    
    <content type="html"><![CDATA[<p>自动装配原理介绍</p><span id="more"></span><h2 id="启动类注解"><a href="#启动类注解" class="headerlink" title="启动类注解"></a>启动类注解</h2><p>众所周知，这是springboot的启动类的注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(DemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SpringBootApplication"><a href="#SpringBootApplication" class="headerlink" title="@SpringBootApplication"></a>@SpringBootApplication</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span></span><br><span class="line"><span class="meta">      @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大概可以把 <code>@SpringBootApplication</code>看作是 <code>@Configuration</code>、<code>@EnableAutoConfiguration</code>、<code>@ComponentScan</code> 注解的集合。根据 SpringBoot 官网，这三个注解的作用分别是：</p><ul><li><p><code>@EnableAutoConfiguration</code>：启用 SpringBoot 的自动配置机制</p></li><li><p><code>@Configuration</code>：允许在上下文中注册额外的 bean 或导入其他配置类</p></li><li><p><code>@ComponentScan</code>： 扫描被<code>@Component</code> (<code>@Service</code>,<code>@Controller</code>)注解的 bean，注解默认会扫描启动类所在的包下所有的类 ，可以自定义不扫描某些 bean。如下图所示，容器中将排除<code>TypeExcludeFilter</code>和<code>AutoConfigurationExcludeFilter</code>。</p><p>@EnableAutoConfiguration` 是实现自动装配的重要注解，我们以这个注解入手。</p></li></ul><h2 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span><span class="comment">//将main包下的所欲组件注册到容器中</span></span><br><span class="line"><span class="meta">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span><span class="comment">//加载自动装配类 xxxAutoconfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br><span class="line">    String ENABLED_OVERRIDE_PROPERTY = <span class="string">&quot;spring.boot.enableautoconfiguration&quot;</span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    String[] excludeName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个注解最重要的就是    AutoConfigurationImportSelector这个类了</p><h3 id="AutoConfigurationImportSelector"><a href="#AutoConfigurationImportSelector" class="headerlink" title="AutoConfigurationImportSelector"></a>AutoConfigurationImportSelector</h3><p>AutoConfigurationImportSelector中重要的方法就是这个，主要负责加载自动配置类的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> AutoConfigurationEntry <span class="title">getAutoConfigurationEntry</span><span class="params">(AnnotationMetadata annotationMetadata)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (!isEnabled(annotationMetadata)) &#123;</span><br><span class="line">      <span class="keyword">return</span> EMPTY_ENTRY;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//默认情况下返回的是@EnableAutoConfiguration中的两个属性</span></span><br><span class="line">   AnnotationAttributes attributes = getAttributes(annotationMetadata);</span><br><span class="line">   List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes);</span><br><span class="line">   configurations = removeDuplicates(configurations);</span><br><span class="line">   Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);</span><br><span class="line">   checkExcludedClasses(configurations, exclusions);</span><br><span class="line">   configurations.removeAll(exclusions);</span><br><span class="line">   configurations = getConfigurationClassFilter().filter(configurations);</span><br><span class="line">   fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> AutoConfigurationEntry(configurations, exclusions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="getAttributes"><a href="#getAttributes" class="headerlink" title="getAttributes"></a>getAttributes</h4><p>这个方法返回了@EnableAutoConfiguration中的两个属性</p><p><img src="https://gitee.com/flow_disaster/blog-map-bed/raw/master/img/image-20210514093032660.png" alt="image-20210514093032660"></p><h4 id="getCandidateConfigurations"><a href="#getCandidateConfigurations" class="headerlink" title="getCandidateConfigurations"></a>getCandidateConfigurations</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回应考虑的自动配置类名称。 默认情况下，此方法将使用SpringFactoriesLoader和getSpringFactoriesLoaderFactoryClass()来加载候选SpringFactoriesLoader 。</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;String&gt; <span class="title">getCandidateConfigurations</span><span class="params">(AnnotationMetadata metadata, AnnotationAttributes attributes)</span> </span>&#123;</span><br><span class="line">   List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(),</span><br><span class="line">         getBeanClassLoader());</span><br><span class="line">   Assert.notEmpty(configurations, <span class="string">&quot;No auto configuration classes found in META-INF/spring.factories. If you &quot;</span></span><br><span class="line">         + <span class="string">&quot;are using a custom packaging, make sure that file is correct.&quot;</span>);</span><br><span class="line">   <span class="keyword">return</span> configurations;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h4><p>这个方法主要是扫描到所有的</p><p><img src="https://gitee.com/flow_disaster/blog-map-bed/raw/master/img/image-20210514093526289.png" alt="image-20210514093526289"></p><p>去除一些</p><p><img src="https://gitee.com/flow_disaster/blog-map-bed/raw/master/img/image-20210514094139509.png" alt="image-20210514094139509"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;自动装配原理介绍&lt;/p&gt;</summary>
    
    
    
    
    <category term="SpringBoot" scheme="https://shyblog.world/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>分布式锁</title>
    <link href="https://shyblog.world/posts/1320368156.html"/>
    <id>https://shyblog.world/posts/1320368156.html</id>
    <published>2021-05-13T05:03:38.000Z</published>
    <updated>2021-07-12T23:24:47.519Z</updated>
    
    <content type="html"><![CDATA[<p>分析分布式锁的实现</p><span id="more"></span><h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p>为什么需要分布式锁？</p><p>主要是由于在单服务器系统我们常用本地锁来避免并发带来的问题，但是，当服务采用集群方式部署时，本地锁无法在多个服务器之间生效，这时候保证数据的一致性就需要分布式锁来实现。</p><h2 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h2><p>一个相对安全的分布式锁具备什么特征？</p><ul><li>互斥性。互斥是锁的基本特征，同一时刻锁只能被一个线程持有，执行临界区操作。</li><li>超时释放。通过超时释放，可以避免死锁，防止不必要的线程等待和资源浪费，类似于 MySQL 的 InnoDB 引擎中的 innodblockwait_timeout 参数配置。</li><li>可重入性。一个线程在持有锁的情况可以对其再次请求加锁，防止锁在线程执行完临界区操作之前释放。</li><li>高性能和高可用。加锁和释放锁的过程性能开销要尽可能的低，同时也要保证高可用，防止分布式锁意外失效。</li></ul><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><ul><li><strong>Memcached 分布式锁</strong></li><li>利用 Memcached 的 add 命令。此命令是原子性操作，只有在 key 不存在的情况下，才能 add 成功，也就意味着线程得到了锁。</li><li><strong>Zookeeper 分布式锁</strong></li><li>利用 Zookeeper 的顺序临时节点，来实现分布式锁和等待队列。ZooKeeper 作为一个专门为分布式应用提供方案的框架，它提供了一些非常好的特性，如 ephemeral 类型的 znode 自动删除的功能，同时 ZooKeeper 还提供 watch 机制，可以让分布式锁在客户端用起来就像一个本地的锁一样：加锁失败就阻塞住，直到获取到锁为止。</li><li><strong>Chubby</strong></li><li>Google 公司实现的粗粒度分布式锁服务，有点类似于 ZooKeeper，但也存在很多差异。Chubby 通过 sequencer 机制解决了请求延迟造成的锁失效的问题。</li><li><strong>Redis 分布式锁</strong></li><li>基于 Redis 单机实现的分布式锁，其方式和 Memcached 的实现方式类似，利用 Redis 的 SETNX 命令，此命令同样是原子性操作，只有在 key 不存在的情况下，才能 set 成功。而基于 Redis 多机实现的分布式锁 Redlock，是 Redis 的作者 antirez 为了规范 Redis 分布式锁的实现，提出的一个更安全有效的实现机制。</li></ul><h3 id="redis分布式锁"><a href="#redis分布式锁" class="headerlink" title="redis分布式锁"></a>redis分布式锁</h3><h4 id="setnx"><a href="#setnx" class="headerlink" title="setnx"></a>setnx</h4><p>最简单的加锁方式就是直接使用 Redis 的 SETNX 指令，该指令只在 key 不存在的情况下，将 key 的值设置为 value，若 key 已经存在，则 SETNX 命令不做任何动作。key 是锁的唯一标识，可以按照业务需要锁定的资源来命名。</p><p><img src="https://gitee.com/flow_disaster/blog-map-bed/raw/master/img/image-20210513152055007.png" alt="image-20210513152055007"></p><p>为了防止资源被长期占用，所以需要设置一个过期时间</p><p><img src="https://gitee.com/flow_disaster/blog-map-bed/raw/master/img/image-20210513152129848.png" alt="image-20210513152129848"></p><p>由于setnx和expire不是原子性的操作，所以还是存在这个过期时间没有加上的原因，资源还是被长期占用了</p><p>所以可以用redis的扩展命令</p><p><img src="https://gitee.com/flow_disaster/blog-map-bed/raw/master/img/image-20210513152721214.png" alt="image-20210513152721214"></p><blockquote><ul><li>NX 表示只有当 lock_resource_id 对应的 key 值不存在的时候才能 SET 成功。保证了只有第一个请求的客户端才能获得锁，而其它客户端在锁被释放之前都无法获得锁。</li><li>EX 10 表示这个锁 10 秒钟后会自动过期，业务可以根据实际情况设置这个时间的大小。</li></ul></blockquote><p>但是这种方式仍然不能彻底解决分布式锁超时问题：</p><ul><li>锁被提前释放。假如线程 A 在加锁和释放锁之间的逻辑执行的时间过长（或者线程 A 执行过程中被堵塞），以至于超出了锁的过期时间后进行了释放，但线程 A 在临界区的逻辑还没有执行完，那么这时候线程 B 就可以提前重新获取这把锁，导致临界区代码不能严格的串行执行。</li><li>锁被误删。假如以上情形中的线程 A 执行完后，它并不知道此时的锁持有者是线程 B，线程 A 会继续执行 DEL 指令来释放锁，如果线程 B 在临界区的逻辑还没有执行完，线程 A 实际上释放了线程 B 的锁。</li></ul><p>锁被误删除的解决办法：</p><p>就是在加锁时将 value 设置为一个唯一的随机数（或者线程 ID ），释放锁时先判断随机数是否一致，然后再执行释放操作，确保不会错误地释放其它线程持有的锁，除非是锁过期了被服务器自动释放。</p><p>但是由于判断 value 和删除 key 是两个独立的操作，并不是原子性的，所以这个地方需要使用 Lua 脚本进行处理，因为 Lua 脚本可以保证连续多个指令的原子性执行。</p><blockquote><p>但是，上面这个处理方法还是没有保证锁可能被提前释放的问题，所以有了下面的这种redisson的处理方式</p></blockquote><h4 id="Redisson"><a href="#Redisson" class="headerlink" title="Redisson"></a><strong>Redisson</strong></h4><p>怎么能解决锁被提前释放这个问题呢？</p><p>可以利用锁的可重入特性，让获得锁的线程开启一个定时器的守护线程，每 expireTime/3 执行一次，去检查该线程的锁是否存在，如果存在则对锁的过期时间重新设置为 expireTime，即利用守护线程对锁进行“续命”，防止锁由于过期提前释放。</p><p>当然业务要实现这个守护进程的逻辑还是比较复杂的，可能还会出现一些未知的问题。</p><p>目前互联网公司在生产环境用的比较广泛的开源框架 Redisson 很好地解决了这个问题，非常的简便易用，且支持 Redis 单实例、Redis M-S、Redis Sentinel、Redis Cluster 等多种部署架构。</p><h4 id="Redlock"><a href="#Redlock" class="headerlink" title="Redlock"></a>Redlock</h4><p>出现这个锁的原因是，上面两种的分布式锁都只是作用在了是加锁时只作用在一个 Redis 节点上，即使 Redis 通过 Sentinel 保证了高可用，但由于 Redis 的复制是异步的，Master 节点获取到锁后在未完成数据同步的情况下发生故障转移，此时其他客户端上的线程依然可以获取到锁，因此会丧失锁的安全性。</p><blockquote><p>参考文章：</p><ul><li><a href="https://www.infoq.cn/article/dvaaj71f4fbqsxmgvdce">https://www.infoq.cn/article/dvaaj71f4fbqsxmgvdce</a></li></ul></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;分析分布式锁的实现&lt;/p&gt;</summary>
    
    
    
    
    <category term="redis" scheme="https://shyblog.world/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Spring注解</title>
    <link href="https://shyblog.world/posts/1372806157.html"/>
    <id>https://shyblog.world/posts/1372806157.html</id>
    <published>2021-05-10T14:02:59.000Z</published>
    <updated>2021-07-12T23:24:47.519Z</updated>
    
    <content type="html"><![CDATA[<p>深入理解spring注解的构成</p><span id="more"></span><h2 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> zhujie &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实最简单注解就是这样的，直接使用@interface后面跟上你想自定义的注解的名字即可</p><p>当然了，有一些本身在注解上常用的注解，下面一一来介绍。</p><h2 id="原生注解"><a href="#原生注解" class="headerlink" title="原生注解"></a>原生注解</h2><h3 id="target"><a href="#target" class="headerlink" title="@target"></a>@target</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.ANNOTATION_TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Target &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns an array of the kinds of elements an annotation type</span></span><br><span class="line"><span class="comment">     * can be applied to.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> an array of the kinds of elements an annotation type</span></span><br><span class="line"><span class="comment">     * can be applied to</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ElementType[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>elementpye</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">ElementType</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** Class, interface (including annotation type), or enum declaration */</span></span><br><span class="line">    <span class="comment">//类，接口或者枚举类</span></span><br><span class="line">    TYPE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Field declaration (includes enum constants) */</span></span><br><span class="line">    <span class="comment">//变量声明</span></span><br><span class="line">    FIELD,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Method declaration */</span></span><br><span class="line">    <span class="comment">//方法声明</span></span><br><span class="line">    METHOD,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Formal parameter declaration */</span></span><br><span class="line">    <span class="comment">//格式化声明</span></span><br><span class="line">    PARAMETER,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Constructor declaration */</span></span><br><span class="line">    <span class="comment">//构造声明</span></span><br><span class="line">    CONSTRUCTOR,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Local variable declaration */</span></span><br><span class="line">    <span class="comment">//本地变量声明</span></span><br><span class="line">    LOCAL_VARIABLE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Annotation type declaration */</span></span><br><span class="line">    <span class="comment">//注解类型声明</span></span><br><span class="line">    ANNOTATION_TYPE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Package declaration */</span></span><br><span class="line">    <span class="comment">//打包</span></span><br><span class="line">    PACKAGE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Type parameter declaration</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TYPE_PARAMETER,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Use of a type</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//用户类型</span></span><br><span class="line">    TYPE_USE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a>@Retention</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.ANNOTATION_TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Retention &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the retention policy.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the retention policy</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">RetentionPolicy <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">RetentionPolicy</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Annotations are to be discarded by the compiler.</span></span><br><span class="line"><span class="comment">     * 批注将被编译器丢弃</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SOURCE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Annotations are to be recorded in the class file by the compiler</span></span><br><span class="line"><span class="comment">     * but need not be retained by the VM at run time.  This is the default</span></span><br><span class="line"><span class="comment">     * behavior.</span></span><br><span class="line"><span class="comment">     *注释将由编译器记录在类文件中，但VM不必在运行时保留它们。 这是默认行为。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    CLASS,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Annotations are to be recorded in the class file by the compiler and</span></span><br><span class="line"><span class="comment">     * retained by the VM at run time, so they may be read reflectively.</span></span><br><span class="line"><span class="comment">     *注释将由编译器记录在类文件中，并在运行时由VM保留，因此可以通过反射方式读取它们。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> java.lang.reflect.AnnotatedElement</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    RUNTIME</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Documented"><a href="#Documented" class="headerlink" title="@Documented"></a>@Documented</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.ANNOTATION_TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Documented &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;深入理解spring注解的构成&lt;/p&gt;</summary>
    
    
    
    
    <category term="spring" scheme="https://shyblog.world/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>hashCode和equals关系</title>
    <link href="https://shyblog.world/posts/4257409245.html"/>
    <id>https://shyblog.world/posts/4257409245.html</id>
    <published>2021-05-10T09:37:29.000Z</published>
    <updated>2021-07-12T23:24:47.519Z</updated>
    
    <content type="html"><![CDATA[<p> 详细对比hashCode和equals</p><span id="more"></span><h2 id="hashCode-和equals-是什么？"><a href="#hashCode-和equals-是什么？" class="headerlink" title="hashCode()和equals()是什么？"></a><strong>hashCode()和equals()是什么？</strong></h2><p>hashCode()方法和equals()方法的作用其实一样，在Java里都是用来对比两个对象是否相等一致。</p><h2 id="hashCode-和equals-区别是什么？"><a href="#hashCode-和equals-区别是什么？" class="headerlink" title="hashCode()和equals()区别是什么？"></a>hashCode()和equals()区别是什么？</h2><h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>就性能来说，肯定是hashcode更快一下，毕竟只需要比较hashcode值就好</p><p>equals的话，比如String类型，如果是字符串比较大的话，比较起来就比较慢，如果字符串比较小的话，就比较快</p><h3 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h3><ul><li>equals()相等的两个对象他们的hashCode()肯定相等，也就是用equals()对比是绝对可靠的。</li><li>hashCode()相等的两个对象他们的equals()不一定相等，也就是hashCode()不是绝对可靠的。</li></ul><h2 id="为何重写equals也要重写hashcode"><a href="#为何重写equals也要重写hashcode" class="headerlink" title="为何重写equals也要重写hashcode"></a>为何重写equals也要重写hashcode</h2><p>如果你重写了equals，比如说是基于对象的内容实现的，而保留hashCode的实现不变，那么很可能某两个对象明明是“相等”，而hashCode却不一样。</p><p>这样，当你用其中的一个作为键保存到hashMap、hasoTable或hashSet中，再以“相等的”找另一个作为键值去查找他们的时候，则根本找不到。</p><h2 id="为什么equals-相等，hashCode就一定要相等，而hashCode相等，却不要求equals相等"><a href="#为什么equals-相等，hashCode就一定要相等，而hashCode相等，却不要求equals相等" class="headerlink" title="为什么equals()相等，hashCode就一定要相等，而hashCode相等，却不要求equals相等?"></a><strong>为什么equals()相等，hashCode就一定要相等，而hashCode相等，却不要求equals相等?</strong></h2><ul><li>因为是按照hashCode来访问小内存块，所以hashCode必须相等。</li><li>HashMap获取一个对象是比较key的hashCode相等和equals为true。</li></ul><p>之所以hashCode相等，却可以equal不等，就比如ObjectA和ObjectB他们都有属性name，那么hashCode都以name计算，所以hashCode一样，但是两个对象属于不同类型，所以equals为false。</p><h2 id="阿里相关约束"><a href="#阿里相关约束" class="headerlink" title="阿里相关约束"></a>阿里相关约束</h2><ul><li>只要重写 equals，就必须重写 hashCode；</li><li>因为 Set 存储的是不重复的对象，依据 hashCode 和 equals 进行判断，所以 Set 存储的对象必须重写这两个方法；</li><li>如果自定义对象做为 Map 的键，那么必须重写 hashCode 和 equals；</li><li>String 重写了 hashCode 和 equals 方法，所以我们可以非常愉快地使用 String 对象作为 key 来使用；</li></ul><blockquote><p>参考链接：</p><p><a href="https://zhuanlan.zhihu.com/p/58337357">https://zhuanlan.zhihu.com/p/58337357</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt; 详细对比hashCode和equals&lt;/p&gt;</summary>
    
    
    
    
    <category term="java" scheme="https://shyblog.world/tags/java/"/>
    
  </entry>
  
</feed>
